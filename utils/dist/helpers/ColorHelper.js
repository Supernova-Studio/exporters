"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorHelper = void 0;
const ColorFormat_1 = require("../enums/ColorFormat");
const TokenHelper_1 = require("./TokenHelper");
/** A utility class to help with transformation of colors to various formats */
class ColorHelper {
    /**
     * Behaves like a normal color formatter. However, if the color is reference, it returns the variable name instead of the formatted color.
     * Precise behavior is as follows:
     * - If the color is full reference, returns the variable name
     * - If the color is partial reference, returns the formatted color with references where possible and raw values where not
     * - Only supported partial reference formats are rgb, rgba, smartRgb
     * - Variable names are generated by the provided functions
     */
    static formattedColorOrVariableName(color, allTokens, options) {
        let fullReferenceName = undefined;
        let colorReferenceName = null;
        let opacityReferenceName = null;
        // Check references first
        const fullToken = (0, TokenHelper_1.sureOptionalReference)(color.referencedTokenId, allTokens, options.allowReferences);
        if (fullToken) {
            fullReferenceName = options.tokenToVariableRef(fullToken);
        }
        else {
            const colorToken = (0, TokenHelper_1.sureOptionalReference)(color.color.referencedTokenId, allTokens, options.allowReferences);
            if (colorToken) {
                colorReferenceName = options.tokenToVariableRef(colorToken);
            }
            const opacityToken = (0, TokenHelper_1.sureOptionalReference)(color.opacity.referencedTokenId, allTokens, options.allowReferences);
            if (opacityToken) {
                opacityReferenceName = options.tokenToVariableRef(opacityToken);
            }
        }
        // If the full value is reference, return the variable name
        if (fullReferenceName) {
            return fullReferenceName;
        }
        // If there are no references, format the color raw
        if (!fullReferenceName && !colorReferenceName && !opacityReferenceName) {
            return this.formattedColor(color, options.colorFormat, options.decimals);
        }
        // If there are partial references, we'll use the references where possible and return the raw format for the rest
        switch (options.colorFormat) {
            case ColorFormat_1.ColorFormat.rgb:
            case ColorFormat_1.ColorFormat.rgba:
            case ColorFormat_1.ColorFormat.smartRgba:
                return this.colorToRgb(options.colorFormat, this.normalizedIntColor(color), color.opacity.measure, options.decimals, colorReferenceName, opacityReferenceName);
            default:
                return this.formattedColor(color, options.colorFormat, options.decimals);
        }
    }
    /**
     * Formats Supernova color token value to a string based on the selected format. For fractional formats, the number of decimals can be specified.
     */
    static formattedColor(color, format, decimals = 3) {
        switch (format) {
            case ColorFormat_1.ColorFormat.hex6:
            case ColorFormat_1.ColorFormat.hex8:
            case ColorFormat_1.ColorFormat.hashHex6:
            case ColorFormat_1.ColorFormat.hashHex8:
            case ColorFormat_1.ColorFormat.smartHex:
            case ColorFormat_1.ColorFormat.smartHashHex:
                return this.colorToHex(format, this.normalizedIntColor(color), color.opacity.measure);
            case ColorFormat_1.ColorFormat.rgb:
            case ColorFormat_1.ColorFormat.rgba:
            case ColorFormat_1.ColorFormat.smartRgba:
                return this.colorToRgb(format, this.normalizedIntColor(color), color.opacity.measure, decimals, null, null);
            case ColorFormat_1.ColorFormat.hsl:
            case ColorFormat_1.ColorFormat.hsla:
            case ColorFormat_1.ColorFormat.smartHsla:
                return this.colorToHsl(format, this.normalizedFractionalColor(color), color.opacity.measure, decimals);
            case ColorFormat_1.ColorFormat.smartUIColor:
                return this.colorToUIColor(this.normalizedIntColor(color), color.opacity.measure, decimals);
            case ColorFormat_1.ColorFormat.oklch:
            case ColorFormat_1.ColorFormat.oklcha:
            case ColorFormat_1.ColorFormat.smartOklch:
                return this.colorToOklch(format, this.normalizedIntColor(color), color.opacity.measure, decimals);
            default:
                return this.colorToHex(ColorFormat_1.ColorFormat.smartHashHex, this.normalizedIntColor(color), color.opacity.measure);
        }
    }
    // Convert color to rgb
    static colorToRgb(format, color, alpha, decimals, colorRefReplace, opacityRefReplace) {
        let resultingRgb;
        if (format === ColorFormat_1.ColorFormat.rgba || (format === ColorFormat_1.ColorFormat.smartRgba && alpha < 1)) {
            resultingRgb = `rgba(${colorRefReplace ? colorRefReplace : `${color.r}, ${color.g}, ${color.b}`}, ${opacityRefReplace ? opacityRefReplace : this.roundToDecimals(alpha, decimals)})`;
        }
        else {
            resultingRgb = `rgb(${colorRefReplace ? colorRefReplace : `${color.r}, ${color.g}, ${color.b}`})`;
        }
        return resultingRgb;
    }
    // Convert color to hex
    static colorToHex(format, color, alpha) {
        // Always need hex6
        let resultingHex = `${this.pHex(color.r)}${this.pHex(color.g)}${this.pHex(color.b)}`;
        if (format === ColorFormat_1.ColorFormat.hex8 ||
            format === ColorFormat_1.ColorFormat.hashHex8 ||
            (format === ColorFormat_1.ColorFormat.smartHex && alpha < 1) ||
            (format === ColorFormat_1.ColorFormat.smartHashHex && alpha < 1)) {
            // Add alpha for 8-format
            resultingHex += `${this.pHex(Math.round(alpha * 255))}`;
        }
        if (format === ColorFormat_1.ColorFormat.hashHex6 || format === ColorFormat_1.ColorFormat.hashHex8 || format === ColorFormat_1.ColorFormat.smartHashHex) {
            // Add hash for hash-format
            resultingHex = `#${resultingHex}`;
        }
        return resultingHex;
    }
    // Convert color to HSL
    static colorToHsl(format, color, alpha, decimals) {
        // Calculate HSL values
        const max = Math.max(color.r, color.g, color.b);
        const min = Math.min(color.r, color.g, color.b);
        let h = 0;
        let s = 0;
        let l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const delta = max - min;
            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
            switch (max) {
                case color.r:
                    h = (color.g - color.b) / delta + (color.g < color.b ? 6 : 0);
                    break;
                case color.g:
                    h = (color.b - color.r) / delta + 2;
                    break;
                case color.b:
                    h = (color.r - color.g) / delta + 4;
                    break;
            }
            h /= 6;
        }
        let resultingHsl;
        if (format === ColorFormat_1.ColorFormat.hsla || (format === ColorFormat_1.ColorFormat.smartHsla && alpha < 1)) {
            resultingHsl = `hsla(${Math.round(h * 360)}%, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%, ${this.roundToDecimals(alpha, decimals)})`;
        }
        else {
            resultingHsl = `hsl(${Math.round(h * 360)}%, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
        }
        return resultingHsl;
    }
    // Convert color to UIColor using base constructor
    static colorToUIColor(color, alpha, decimals = 3) {
        let resultingUIColor = `UIColor(rgb: 0x${this.pHex(color.r)}${this.pHex(color.g)}${this.pHex(color.b)})`;
        if (alpha < 1) {
            resultingUIColor += `.withAlphaComponent(${alpha})`;
        }
        return resultingUIColor;
    }
    // Convert color to normalized 0-255 format
    static normalizedIntColor(color) {
        return {
            r: Math.round(color.color.r),
            g: Math.round(color.color.g),
            b: Math.round(color.color.b)
        };
    }
    // Convert color to normalized 0-1 format
    static normalizedFractionalColor(color, decimals = 3) {
        return {
            r: this.roundToDecimals(color.color.r / 255, decimals),
            g: ColorHelper.roundToDecimals(color.color.g / 255, decimals),
            b: ColorHelper.roundToDecimals(color.color.b / 255, decimals)
        };
    }
    // Round half away from zero to a specific number of decimals
    static roundToDecimals(value, decimals, forceTrailingZero = false) {
        const multiplier = Math.pow(10, decimals);
        const rounded = Math.round(value * multiplier) / multiplier;
        if (forceTrailingZero) {
            // Convert to string with fixed decimals and parse back to number
            return Number(rounded.toFixed(decimals));
        }
        // Convert to string and parse back to number to remove unnecessary trailing zeroes
        return parseFloat(rounded.toFixed(decimals));
    }
    // Return hex value with leading zero if hex is single digit
    static pHex(value) {
        return value.toString(16).padStart(2, '0');
    }
    /**
     * Convert color to OKLCH format
     * Handles three formats:
     * - oklch: Always without alpha
     * - oklcha: Always with alpha
     * - smartOklch: With alpha only when alpha < 1
     */
    static colorToOklch(format, color, alpha, decimals) {
        // Convert RGB to OKLCH
        const { l, c, h } = this.rgbToOklch(color.r, color.g, color.b);
        // Format the output string based on format and alpha
        switch (format) {
            case ColorFormat_1.ColorFormat.oklcha:
                return `oklch(${l}% ${c} ${h} / ${this.roundToDecimals(alpha * 100, decimals)}%)`;
            case ColorFormat_1.ColorFormat.smartOklch:
                return alpha < 1
                    ? `oklch(${l}% ${c} ${h} / ${this.roundToDecimals(alpha * 100, decimals)}%)`
                    : `oklch(${l}% ${c} ${h})`;
            case ColorFormat_1.ColorFormat.oklch:
            default:
                return `oklch(${l}% ${c} ${h})`;
        }
    }
    /**
     * Convert RGB (0-255) to OKLCH
     * Returns lightness (0-100), chroma (0-0.4), and hue (0-360)
     */
    static rgbToOklch(r, g, b) {
        // First convert RGB (0-255) to linear RGB (0-1)
        const lr = this.sRGBtoLinear(r / 255);
        const lg = this.sRGBtoLinear(g / 255);
        const lb = this.sRGBtoLinear(b / 255);
        // Convert to XYZ using D65 illuminant
        const x = 0.4124564 * lr + 0.3575761 * lg + 0.1804375 * lb;
        const y = 0.2126729 * lr + 0.7151522 * lg + 0.0721750 * lb;
        const z = 0.0193339 * lr + 0.1191920 * lg + 0.9503041 * lb;
        // Convert to LMS
        const lms_l = 0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z;
        const lms_m = 0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z;
        const lms_s = 0.0482003018 * x + 0.2643662691 * y + 0.6338517070 * z;
        // Non-linear compression
        const lp = Math.cbrt(lms_l);
        const mp = Math.cbrt(lms_m);
        const sp = Math.cbrt(lms_s);
        // Convert to Lab'
        const L = 0.2104542553 * lp + 0.7936177850 * mp - 0.0040720468 * sp;
        const lab_a = 1.9779984951 * lp - 2.4285922050 * mp + 0.4505937099 * sp;
        const lab_b = 0.0259040371 * lp + 0.7827717662 * mp - 0.8086757660 * sp;
        // Convert to LCH
        const C = Math.sqrt(lab_a * lab_a + lab_b * lab_b);
        let h = Math.atan2(lab_b, lab_a) * 180 / Math.PI;
        // Normalize hue to 0-360
        if (h < 0) {
            h += 360;
        }
        // Convert L to percentage and round values
        return {
            l: this.roundToDecimals(L * 100, 2),
            c: this.roundToDecimals(C, 3, true),
            h: this.roundToDecimals(h, 2)
        };
    }
    /**
     * Convert sRGB to linear RGB
     */
    static sRGBtoLinear(x) {
        return x <= 0.04045
            ? x / 12.92
            : Math.pow((x + 0.055) / 1.055, 2.4);
    }
}
exports.ColorHelper = ColorHelper;
