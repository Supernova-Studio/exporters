import { ColorTokenValue, Token } from '@supernovaio/sdk-exporters'
import { ColorFormat } from '../enums/ColorFormat'
import { sureOptionalReference } from './TokenHelper'

/** A utility class to help with transformation of colors to various formats */
export class ColorHelper {
  /**
   * Behaves like a normal color formatter. However, if the color is reference, it returns the variable name instead of the formatted color.
   * Precise behavior is as follows:
   * - If the color is full reference, returns the variable name
   * - If the color is partial reference, returns the formatted color with references where possible and raw values where not
   * - Only supported partial reference formats are rgb, rgba, smartRgb
   * - Variable names are generated by the provided functions
   */
  static formattedColorOrVariableName(
    color: ColorTokenValue,
    allTokens: Map<string, Token>,
    options: {
      allowReferences: boolean
      colorFormat: ColorFormat
      decimals: number
      tokenToVariableRef: (token: Token) => string
    }
  ): string {
    let fullReferenceName: string | undefined = undefined
    let colorReferenceName: string | null = null
    let opacityReferenceName: string | null = null

    // Check references first
    const fullToken = sureOptionalReference(color.referencedTokenId, allTokens, options.allowReferences)
    if (fullToken) {
      fullReferenceName = options.tokenToVariableRef(fullToken)
    } else {
      const colorToken = sureOptionalReference(color.color.referencedTokenId, allTokens, options.allowReferences)
      if (colorToken) {
        colorReferenceName = options.tokenToVariableRef(colorToken)
      }
      const opacityToken = sureOptionalReference(color.opacity.referencedTokenId, allTokens, options.allowReferences)
      if (opacityToken) {
        opacityReferenceName = options.tokenToVariableRef(opacityToken)
      }
    }

    // If the full value is reference, return the variable name
    if (fullReferenceName) {
      return fullReferenceName
    }

    // If there are no references, format the color raw
    if (!fullReferenceName && !colorReferenceName && !opacityReferenceName) {
      return this.formattedColor(color, options.colorFormat, options.decimals)
    }

    // If there are partial references, we'll use the references where possible and return the raw format for the rest
    switch (options.colorFormat) {
      case ColorFormat.rgb:
      case ColorFormat.rgba:
      case ColorFormat.smartRgba:
        return this.colorToRgb(
          options.colorFormat,
          this.normalizedIntColor(color),
          color.opacity.measure,
          options.decimals,
          colorReferenceName,
          opacityReferenceName
        )
      default:
        return this.formattedColor(color, options.colorFormat, options.decimals)
    }
  }

  /**
   * Formats Supernova color token value to a string based on the selected format. For fractional formats, the number of decimals can be specified.
   */
  static formattedColor(color: ColorTokenValue, format: ColorFormat, decimals: number = 3): string {
    switch (format) {
      case ColorFormat.hex6:
      case ColorFormat.hex8:
      case ColorFormat.hashHex6:
      case ColorFormat.hashHex8:
      case ColorFormat.smartHex:
      case ColorFormat.smartHashHex:
        return this.colorToHex(format, this.normalizedIntColor(color), color.opacity.measure)
      case ColorFormat.rgb:
      case ColorFormat.rgba:
      case ColorFormat.smartRgba:
        return this.colorToRgb(format, this.normalizedIntColor(color), color.opacity.measure, decimals, null, null)
      case ColorFormat.hsl:
      case ColorFormat.hsla:
      case ColorFormat.smartHsla:
        return this.colorToHsl(format, this.normalizedFractionalColor(color), color.opacity.measure, decimals)
      case ColorFormat.smartUIColor:
        return this.colorToUIColor(this.normalizedIntColor(color), color.opacity.measure, decimals)
      case ColorFormat.oklch:
      case ColorFormat.oklcha:
      case ColorFormat.smartOklch:
        return this.colorToOklch(format, this.normalizedIntColor(color), color.opacity.measure, decimals)
      default:
        return this.colorToHex(ColorFormat.smartHashHex, this.normalizedIntColor(color), color.opacity.measure)
    }
  }

  // Convert color to rgb
  static colorToRgb(
    format: ColorFormat,
    color: { r: number; g: number; b: number },
    alpha: number,
    decimals: number,
    colorRefReplace: string | null,
    opacityRefReplace: string | null
  ): string {
    let resultingRgb: string
    if (format === ColorFormat.rgba || (format === ColorFormat.smartRgba && alpha < 1)) {
      resultingRgb = `rgba(${colorRefReplace ? colorRefReplace : `${color.r}, ${color.g}, ${color.b}`}, ${
        opacityRefReplace ? opacityRefReplace : this.roundToDecimals(alpha, decimals)
      })`
    } else {
      resultingRgb = `rgb(${colorRefReplace ? colorRefReplace : `${color.r}, ${color.g}, ${color.b}`})`
    }

    return resultingRgb
  }

  // Convert color to hex
  static colorToHex(format: ColorFormat, color: { r: number; g: number; b: number }, alpha: number): string {
    // Always need hex6
    let resultingHex = `${this.pHex(color.r)}${this.pHex(color.g)}${this.pHex(color.b)}`
    if (
      format === ColorFormat.hex8 ||
      format === ColorFormat.hashHex8 ||
      (format === ColorFormat.smartHex && alpha < 1) ||
      (format === ColorFormat.smartHashHex && alpha < 1)
    ) {
      // Add alpha for 8-format
      resultingHex += `${this.pHex(Math.round(alpha * 255))}`
    }
    if (format === ColorFormat.hashHex6 || format === ColorFormat.hashHex8 || format === ColorFormat.smartHashHex) {
      // Add hash for hash-format
      resultingHex = `#${resultingHex}`
    }

    return resultingHex
  }

  // Convert color to HSL
  static colorToHsl(
    format: ColorFormat,
    color: { r: number; g: number; b: number },
    alpha: number,
    decimals: number
  ): string {
    // Calculate HSL values
    const max = Math.max(color.r, color.g, color.b)
    const min = Math.min(color.r, color.g, color.b)
    let h = 0
    let s = 0
    let l = (max + min) / 2

    if (max === min) {
      h = s = 0 // achromatic
    } else {
      const delta = max - min
      s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min)
      
      switch (max) {
        case color.r:
          h = (color.g - color.b) / delta + (color.g < color.b ? 6 : 0)
          break
        case color.g:
          h = (color.b - color.r) / delta + 2
          break
        case color.b:
          h = (color.r - color.g) / delta + 4
          break
      }
      h /= 6
    }

    let resultingHsl: string
    if (format === ColorFormat.hsla || (format === ColorFormat.smartHsla && alpha < 1)) {
      resultingHsl = `hsla(${Math.round(h * 360)}%, ${Math.round(s * 100)}%, ${Math.round(
        l * 100
      )}%, ${this.roundToDecimals(alpha, decimals)})`
    } else {
      resultingHsl = `hsl(${Math.round(h * 360)}%, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`
    }

    return resultingHsl
  }

  // Convert color to UIColor using base constructor
  static colorToUIColor(color: { r: number; g: number; b: number }, alpha: number, decimals: number = 3): string {
    let resultingUIColor = `UIColor(rgb: 0x${this.pHex(color.r)}${this.pHex(color.g)}${this.pHex(color.b)})`
    if (alpha < 1) {
      resultingUIColor += `.withAlphaComponent(${alpha})`
    }

    return resultingUIColor
  }

  // Convert color to normalized 0-255 format
  private static normalizedIntColor(color: ColorTokenValue): {
    r: number
    g: number
    b: number
  } {
    return {
      r: Math.round(color.color.r),
      g: Math.round(color.color.g),
      b: Math.round(color.color.b)
    }
  }

  // Convert color to normalized 0-1 format
  private static normalizedFractionalColor(
    color: ColorTokenValue,
    decimals: number = 3
  ): { r: number; g: number; b: number } {
    return {
      r: this.roundToDecimals(color.color.r / 255, decimals),
      g: ColorHelper.roundToDecimals(color.color.g / 255, decimals),
      b: ColorHelper.roundToDecimals(color.color.b / 255, decimals)
    }
  }

  // Round half away from zero to a specific number of decimals
  static roundToDecimals(value: number, decimals: number, forceTrailingZero: boolean = false): number {
    const multiplier = Math.pow(10, decimals)
    const rounded = Math.round(value * multiplier) / multiplier

    if (forceTrailingZero) {
      // Convert to string with fixed decimals and parse back to number
      return Number(rounded.toFixed(decimals))
    }

    // Convert to string and parse back to number to remove unnecessary trailing zeroes
    return parseFloat(rounded.toFixed(decimals))
  }

  // Return hex value with leading zero if hex is single digit
  private static pHex(value: number): string {
    return value.toString(16).padStart(2, '0')
  }

  /**
   * Convert color to OKLCH format
   * Handles three formats:
   * - oklch: Always without alpha
   * - oklcha: Always with alpha
   * - smartOklch: With alpha only when alpha < 1
   */
  static colorToOklch(
    format: ColorFormat,
    color: { r: number; g: number; b: number },
    alpha: number,
    decimals: number
  ): string {
    // Convert RGB to OKLCH
    const { l, c, h } = this.rgbToOklch(color.r, color.g, color.b)
    
    // Format the output string based on format and alpha
    switch (format) {
      case ColorFormat.oklcha:
        return `oklch(${l}% ${c} ${h} / ${this.roundToDecimals(alpha * 100, decimals)}%)`
      case ColorFormat.smartOklch:
        return alpha < 1 
          ? `oklch(${l}% ${c} ${h} / ${this.roundToDecimals(alpha * 100, decimals)}%)`
          : `oklch(${l}% ${c} ${h})`
      case ColorFormat.oklch:
      default:
        return `oklch(${l}% ${c} ${h})`
    }
  }

  /**
   * Convert RGB (0-255) to OKLCH
   * Returns lightness (0-100), chroma (0-0.4), and hue (0-360)
   */
  private static rgbToOklch(r: number, g: number, b: number): { l: number; c: number; h: number } {
    // First convert RGB (0-255) to linear RGB (0-1)
    const lr = this.sRGBtoLinear(r / 255)
    const lg = this.sRGBtoLinear(g / 255)
    const lb = this.sRGBtoLinear(b / 255)

    // Convert to XYZ using D65 illuminant
    const x = 0.4124564 * lr + 0.3575761 * lg + 0.1804375 * lb
    const y = 0.2126729 * lr + 0.7151522 * lg + 0.0721750 * lb
    const z = 0.0193339 * lr + 0.1191920 * lg + 0.9503041 * lb

    // Convert to LMS
    const lms_l = 0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z
    const lms_m = 0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z
    const lms_s = 0.0482003018 * x + 0.2643662691 * y + 0.6338517070 * z

    // Non-linear compression
    const lp = Math.cbrt(lms_l)
    const mp = Math.cbrt(lms_m)
    const sp = Math.cbrt(lms_s)

    // Convert to Lab'
    const L = 0.2104542553 * lp + 0.7936177850 * mp - 0.0040720468 * sp
    const lab_a = 1.9779984951 * lp - 2.4285922050 * mp + 0.4505937099 * sp
    const lab_b = 0.0259040371 * lp + 0.7827717662 * mp - 0.8086757660 * sp

    // Convert to LCH
    const C = Math.sqrt(lab_a * lab_a + lab_b * lab_b)
    let h = Math.atan2(lab_b, lab_a) * 180 / Math.PI

    // Normalize hue to 0-360
    if (h < 0) {
      h += 360
    }

    // Convert L to percentage and round values
    return {
      l: this.roundToDecimals(L * 100, 2),
      c: this.roundToDecimals(C, 3, true),
      h: this.roundToDecimals(h, 2)
    }
  }

  /**
   * Convert sRGB to linear RGB
   */
  private static sRGBtoLinear(x: number): number {
    return x <= 0.04045
      ? x / 12.92
      : Math.pow((x + 0.055) / 1.055, 2.4)
  }
}
